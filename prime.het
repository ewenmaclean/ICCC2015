logic CASL
  %%PRIME IDEAS OVER PRINCIPAL IDEAL DOMAINS (PID) AS BLENDS IN CASL

  %% This is a completelly self-contained version of the collection of the
  %% ideals of PID, defined all the necesary sorts, constants, relations, 
  %% operations and axioms by hand.

  spec IdealsOfRing =
        sort RingElt                                          %% sort of Ring Elts
        sort SubSetOfRing                                  
        pred IsIdeal : SubSetOfRing                           %% when a subset is an ideal
        op  0 : RingElt
        op  1 : RingElt
        op  __*__ : RingElt * RingElt -> RingElt
        op  __+__ : RingElt * RingElt -> RingElt

        pred __isIn__ : RingElt * SubSetOfRing

        sort Ideal = { I : SubSetOfRing . IsIdeal(I) }
        op  R : Ideal                                         %% the Ring as an ideal
        op    __ ** __: Ideal * Ideal -> Ideal, unit R
        pred __issubsetOf__ : Ideal * Ideal                 

  %%Definition of the contention predicate      

        forall A,B : Ideal
        . A issubsetOf B <=> forall a: RingElt. a isIn A => a isIn B 

  %% axioms for Ring
      
        forall x : RingElt; y : RingElt . x + y = y + x                          %%Commutativity with +
        forall x : RingElt; y : RingElt; z : RingElt . (x + y) + z = x + (y + z) %%Associativity with +
        forall x : RingElt . x + 0 = x /\ 0 + x = x                              %%unit with +
        forall x : RingElt . exists x' : RingElt . x' + x = 0                    %%Inverse with +
        forall x : RingElt; y : RingElt . x * y = y * x                          %%Commutativity with *
        forall x : RingElt; y : RingElt; z : RingElt . (x * y) * z = x * (y * z) %%Associativity with *
        forall x : RingElt . x * 1 = x /\ 1 * x = x                              %%unit with *
        forall x, y, z : RingElt . (x + y) * z = (x * z) + (y * z)               %%Left_Distributivity
        forall x, y, z : RingElt . z * (x + y) = (z * x) + (z * y)               %%Right_Distributivity

  %%axioms for Ideal

        forall I: SubSetOfRing. IsIdeal(I) <=>
        ( forall a,b,c : RingElt
        .( (a isIn I => a isIn R)
        /\  0 isIn I)
        /\ (a isIn I /\ c isIn R => (c * a) isIn I)
        /\ (a isIn I /\ b isIn I /\ c isIn R /\ b + c = 0 => a + c isIn I ))
        

  %%axioms for PID-s

        pred __generates__: RingElt * Ideal     %%an ideal is generated by an element
        forall A: Ideal. exists a: RingElt. a generates A

        forall a: RingElt. forall A: Ideal. a generates A <=> 
        forall c: RingElt. c isIn A => exists d: RingElt. c=a*d 

  %% Definition of the product of ideals 

        forall A,B: Ideal 
        . forall a,b: RingElt. (a isIn A /\ b isIn B) => a*b isIn A**B
        . forall D: Ideal. (forall a,b: RingElt. (a isIn A /\ b isIn B) => a*b isIn A**B) => A**B issubsetOf D 
end

  %%%  axioms defining a very simple version of the integers,
  %%%  considered with an operation *, a binary relation ||
  %%%  (upside-down divisibility relation) and a primality axiom.

spec SimpleInt=
    sort SimpleElem
    ops 1:  SimpleElem
        __ x __: SimpleElem * SimpleElem -> SimpleElem, unit 1
    preds __ || __: SimpleElem * SimpleElem            
          IsPrime : SimpleElem
    forall x,y: SimpleElem 
        . x || y <=> (exists c: SimpleElem. x = y x c)    %Def_upsidedownDivisilityRelation%

    %% subsort of primes
    sort SimplePrime = { p : SimpleElem . IsPrime(p) }

    forall p:SimpleElem .
        IsPrime(p) <=>
        (forall a,b: SimpleElem
        . a x b || p => a || p \/ b || p                  %Def_primality%
        /\ not (p = 1))
end

  %%% Generic space
 
spec Gen=
    sort Generic
    ops S: Generic
        __ gpr __: Generic * Generic -> Generic, unit S
    pred gcont: Generic * Generic
end
 
view I1: Gen to IdealsOfRing =
        Generic |-> Ideal, S |-> R,
        __ gpr __ |-> __ ** __, gcont |-> __issubsetOf__

view I2: Gen to SimpleInt =
        Generic |-> SimpleElem, S |-> 1,
        __ gpr __ |-> __ x __, gcont |-> __ || __

spec Colimit = combine I1, I2
