   logic CASL
     %% Prime Ideals over Principal Ideal Domains (PID) as
     %% Blends in Casl

spec IdealsOfRing =
           sort RingElt                                      %% sort of Ring Elts
           sort SubSetOfRing                                 %% not further defined for the moment
           pred IsIdeal : SubSetOfRing                       %% when a subset is an ideal
           op  0 : RingElt
           op  1 : RingElt
           op  __*__ : RingElt * RingElt -> RingElt
           op  __+__ : RingElt * RingElt -> RingElt
           pred __isIn__ : RingElt * SubSetOfRing
           sort Ideal = { I : SubSetOfRing . IsIdeal(I) }
           op  R : Ideal                                         %% the Ring as an ideal
           op    __ ** __: Ideal * Ideal -> Ideal, unit R
           pred __issubsetOf__ : Ideal * Ideal                   %% partial order
     %%Definition of the containment predicate
           forall A,B : Ideal
           . A issubsetOf B <=> forall a: RingElt. a isIn A => a isIn B %(subset_def)%
     %% axioms for Ring

           forall x : RingElt; y : RingElt . x + y = y + x       %(Commutativity_+)%
           forall x : RingElt; y : RingElt; z : RingElt
		  . (x + y) + z = x + (y + z)                    %(Associativity +)%
           forall x : RingElt . x + 0 = x /\ 0 + x = x           %(unit_+)%
           forall x : RingElt . exists x' : RingElt
		  . x' + x = 0                                   %(Inverse +)%
           forall x : RingElt; y : RingElt . x * y = y * x       %(Commutativity *)%
           forall x : RingElt; y : RingElt; z : RingElt 
                  . (x * y) * z = x * (y * z)                    %(Associativity *)%
           forall x : RingElt . x * 1 = x /\ 1 * x = x           %(unit *)%
           forall x, y, z : RingElt
		  . (x + y) * z = (x * z) + (y * z)              %(Left_Distributivity)%
           forall x, y, z : RingElt
		  . z * (x + y) = (z * x) + (z * y)              %(Right_Distributivity)%
     %%axioms for Ideal
           forall I: SubSetOfRing. IsIdeal(I) <=>
           ( forall a,b,c : RingElt
           .( (a isIn I => a isIn R)
           /\  0 isIn I)
           /\ (a isIn I /\ c isIn R => (c * a) isIn I)
           /\ (a isIn I /\ b isIn I /\ c isIn R /\ b + c = 0 
            => a + c isIn I ))

     %%axioms for PIDs
           pred __generates__: RingElt * Ideal     %%an ideal is generated by an element
           forall A: Ideal. exists a: RingElt. a generates A
           forall a: RingElt. forall A: Ideal. a generates A <=>
                  forall c: RingElt. (c isIn A => exists d: RingElt. c=a*d)
     %% Definition of the product of ideals
           forall A,B: Ideal
           . forall a,b: RingElt. (a isIn A /\ b isIn B) => a*b isIn A**B
           . forall D: Ideal. (forall a,b: RingElt. (a isIn A /\ b isIn B)
             => a*b isIn A**B) => A**B issubsetOf D
   end
     %%  axioms defining a very simple version of the integers,
     %%  considered with an operation *, a binary relation ||
     %%  (upside-down divisibility relation) and a primality axiom.
   spec SimpleInt=
       sort SimpleElem
       ops 1:  SimpleElem
           __ x __: SimpleElem * SimpleElem -> SimpleElem, comm, assoc,
   unit 1
       preds __ || __: SimpleElem * SimpleElem      %% division gives partial order
             IsPrime : SimpleElem
       forall x,y: SimpleElem
           . x || y <=> (exists c: SimpleElem. x = y x c)
                                              %Def_upsidedownDivisilityRelation%
       %% subsort of primes
       sort SimplePrime = { p : SimpleElem . IsPrime(p) }
       forall p:SimpleElem .
           IsPrime(p) <=>
           (forall a,b: SimpleElem
           . a x b || p => a || p \/ b || p
   %Def_primality%
           /\ not (p = 1))
   end
     %% Generic space

   spec Gen=
       sort Generic
       ops S: Generic
           __ gpr __: Generic * Generic -> Generic, unit S
       pred gcont: Generic * Generic
   end

   view I1: Gen to IdealsOfRing =
           Generic |-> Ideal, S |-> R,
           __ gpr __ |-> __ ** __, gcont |-> __issubsetOf__
   view I2: Gen to SimpleInt =
           Generic |-> SimpleElem, S |-> 1,
           __ gpr __ |-> __ x __, gcont |-> __ || __
   spec Colimit = combine I1, I2


